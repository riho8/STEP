# HW2 (5/19-)

## 宿題の概要

1. ハッシュテーブルの作成
    1. delete() 関数の実装
    2. calculate_hash() 関数の改善
    3. 再ハッシュの実装
2. 実際の大規模なデータベースがハッシュテーブルではなく木構造を採用する理由の説明
3. O(1)でキャッシュを管理できる データ構造の説明

## hw2-1

### **実行方法**

```python
$ python3 hw2-1.py
```

プログラムには、ハッシュテーブルの動作とパフォーマンスをテストするための関数が含まれています。

**`Functional tests passed!`** と **`Performance tests passed!`** と表示されれば成功です。

### **delete() 関数の実装**

以下の手順で実装しました：

1. ハッシュ値を計算します。
2. ハッシュ値に対応するバケットにアクセスし、目的の要素を探します。
3. 目的の要素が見つかれば、それを削除します。

ポイント：

- バケットの先頭に目的の要素があるかどうかによって、削除方法を変えました。

### **calculate_hash() 関数の改善**

以下の手順で実装しました：

1. 現在のハッシュ値に97を掛け、ターゲットの文字のASCII値を足す。
2. 1の値でハッシュ値を更新する。

ポイント：

- 1文字ごとにハッシュ値を更新していくことで、アナグラムの文字同士（例:abc, bca）でも違うハッシュ値が生成されます。
- 97を選んだのは、素数であり、また初期のテーブルサイズが97だったためです。（あまり根拠はないです）

### 再**ハッシュの実装**

以下の手順で実装しました：

**`check_and_resize_table()`**

1. ハッシュテーブルのサイズを変更する必要があるかどうかをチェックします。
    1. テーブルが小さすぎる場合（使用量が30%未満）、`bucket_size`を半分にします。
    2. テーブルが大きすぎる場合（使用量が70%以上）、`bucket_size`を倍にします。

**`rehash()`**

1. 変更した`bucket_size`で新しいハッシュテーブルを作成します。
2. 古いハッシュテーブルの要素を順番に取り出し、新しいハッシュテーブルに入れます。ハッシュ値の計算は新しいサイズに基づいて行います。
3. 新しいハッシュテーブルを使用するように切り替えます。

ポイント：

- バケットサイズは素数である必要があります。そのため、**`nextprime()`** を使用して素数を見つけました。
    - **`from sympy import nextprime`**

## [hw2-2](hw2-2.md)

## [hw2-3](hw2-3.md)