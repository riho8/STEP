# HW4 (6/2-)

## 宿題の概要

日本語Wikipediaのページタイトルと関連リンクのデータセットを用いてグラフ解析をする。

1. [Pythonのサンプルプログラム](https://github.com/xharaken/step2/blob/master/wikipedia.py)にfind_shortest_path()関数を追加し、あるページから別のページへの最短経路を求める
2. find_most_popular_pages()関数を追加し、ページランクを計算して重要度の高いページTop10を求める

## hw4.py

### 実行方法

```python
$ python3 hw4.py <pages_SIZE.txt> <links_SIZE.txt>
```

- データセットは以下の三種類があります。
    - small : テスト用
    - medium : 日本語wikipediaの25%程
    - large : 日本語wikipediaの全部
- 宿題ではsmall と mediumを用いました。

## 1. find_shortest_path()

BFSを用いて最短経路を求める。

手順

1. startとgoalのkeyを取得する。
2. collections.deque()を使ってキューを用意する。
3. キューが空になるまで、以下の処理をする
    1. キューから一つ要素を取り出して、その要素が持つ関連リンクを一つずつ見ていく。
        1. もしその関連リンクが未探索だったら、キューに追加しステータスを探索済みにする。また、pathに{その関連リンク: 親リンク}という形で保存する。
        2. もしその関連リンクがgoalだった場合、pathから最短経路を取得して出力する。
4. goalが見つからなかった場合、”Not found”を返す。

例；A->Dの最短経路を求める

```python
A --> B --> D
|     |
└---> C
```

1. path = {"B":"A", "C":"B", "D":"B"} *実際にはkeyを保存しているので、{2: 1, 3: 2, 4: 2}
2.  path で keyがchildのとき、valueがstart(A) になるまで(path[child] == start)、goal(D)から遡る (child = path[child])
    1. {D:B} ⇒ {B:A}

### 工夫した点

- 辞書で経路を保存し、goalからstartまでの経路が効率よく復元できるようにしました。

## 2. find_most_popular_pages()

手順

1. `ranks`を初期化してページランクを1に設定する。
2. ページランクを更新するための`update_ranks`を初期化する（ページランクは0)。
3. リンクのないページのランクを`nolink_keys`に追加し、リンクのあるページはそのリンクにページランクの85%を均等に分配し、update_rankを更新する。
4. リンクのないページとリンクのあるページのランクをそれぞれ計算し、すべてのページに均等に分配し、update_rankを更新する。
    1. リンクのないページではページランクの100%を分配する
    2. リンクのあるページではページランクの15%を分配する
5. ranksをupdate_ranksの値に書き換える。
6. ページランクの合計値が収束するまで2~5の手順を繰り返し、最終的なページランクをソートして上位10件を表示する。

解説

- 全てのページにページランクの15%、または100%を分配する処理
    - 例えば[1,2,3,4,5]というページランクがあり、2と3がリンクのないページランクだった場合、全てのページに足されるランクは 以下のように表せる。
    
    ```python
    0.15*1/5 + 1.0*2/5 + 1.0* 3/5 + 0.15*4/5 + 0.15*5/5
    ↓
    0.15*(1+4+5)/5 + 1.0*(2+3)/5
    ↓
    (0.15*(1+4+5)+ 1.0*(2+3))/5
    ↓
    (0.15*(ページランクの合計-リンクのないページランクの合計)+ 1.0*(リンクのないページランクの合計)/5
    ```
    
    - forループでリンクのないページに当たった場合、そのページランクを配列で保存してループを抜けた後に計算し、ページランクを更新している。
- 収束したかの判断
    - 上の2~5の処理を10回繰り返す。ページランクの現在の合計値と一つ前の合計値を比較し、その差が0.0001(1e-4)以下だったら収束したと判断しループを抜ける。

### 工夫した点

- 全てのページにページランクの15%、または100%を分配する処理を、１つのページごとに毎回すべてのページにforで分配していたので、計算量がO(N^2)でとても重くなってしまいmediumでは日付を超えても結果が出ないような状態でしたが、処理をfor key in ranksの外に出して合計を足すようにしたら計算量がO(N)になり5分くらいで結果が出るようになりました🎉