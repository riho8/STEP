## HW3

このようなキャッシュの管理をほぼ O(1) で実現できるデータ構造を考えてください！(σ⁎˃ᴗ˂⁎)σ

*このような：もっとも直近にアクセスされたページ上位 X 個をキャッシュしておく😊  
<br>

- 問題：次の操作をほぼ O(1) で実現するデータ構造を考える
    1. 与えられた <URL, Web ページ> があるかないかを検索
    2. もしない場合、キャッシュ内で一番古い <URL, Web ページ> を捨てて、かわりに与えられた <URL, Web ページ> を追加する
    
    **→ハッシュテーブルに循環リスト（単方向）を組み合わせて実現する**
    
- なぜ循環リストか？
    - 先入れ先出し（FIFO：First-In First-Out）のデータ構造→キューが必要
    - キューは単方向リストで実装できる
        - 一つ後ろのデータのポインタを持つ
        - リストの先頭の要素のポインタを持つ
    - ただの単方向リストでキューを実装すると、追加と削除を繰り返すとどんどん配列サイズが大きくなってしまうため、最後の要素の次のポインタを先頭要素のポインタにしておく → 循環リスト
        
        ![Untitled](https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200111234203.gif)
        

```python
class Item:
    def __init__(self, key, value, next):
        assert type(key) == str
        self.key = key
        self.value = value
        self.next = next

class HashList:
	def __init__(self):
	    self.size = x
	    self.buckets= [None] * self.size
			self.item_count = 0
	    self.head = None #先頭のnode
	    self.tail = None #最後のnode tail.next -> head
	
	def enqueue(self, key, value):
		#ハッシュテーブルに追加
		#(headと)tailを更新する
	
	def dequeue(self,key,value):
		key = self.head
		#ハッシュテーブルからkeyを探して削除
		#head(とtail)を更新する

	def update_cache():
		#ハッシュテーブルにあるか探す
		#なかったら
			#item_countがX以上だったら
				dequeue()
			enqueue()
	
update_cache("a.com","web")
```